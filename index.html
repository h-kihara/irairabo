<html>
	<header>
<style type="text/css">
#svg {
  background-color: #c0ffee;
}
.anime1 {
  animation: strokeAnimation1 linear 3s infinite;
}
@keyframes strokeAnimation1{
  from{transform-origin:185px 90px; transform: rotate(0);}
  to  {transform-origin:185px 90px; transform: rotate(360deg);}
}
.button {
  background-color: orange;
  border: gray;
  width: 50px;
  height: 40px;
}
</style>
        </header>
	<body>
		<h1></h1>
		<div>
			<svg id="svg" width="500" height="300" viewBox="-100 -100 500 300">

                        </svg>
		</div>
                <h2 id="timer">--:--.--</h2>
                <div class="button" onclick="StartTimer('inf')">start</div>
                <div id="debug"></div>

	</body>
	<script>
const NS = "http://www.w3.org/2000/svg";
const svg = document.getElementById('svg');
const debugwrite = document.getElementById('debug');
// 自機（カーソル）
let cursor_x = 30;
let cursor_y = 50;
const cursor_r = 10;
const cursor = (function () {
  const cursor = document.createElementNS(NS, 'circle');
  cursor.setAttribute('cx', cursor_x);
  cursor.setAttribute('cy', cursor_y);
  cursor.setAttribute('r', cursor_r);
  cursor.setAttribute('fill', "#ED3");
  cursor.setAttribute('id', 'cursor');
  svg.appendChild(cursor);
  return cursor
})();

function move(dx, dy) {
  const old_x = cursor_x;
  const old_y = cursor_y;
  cursor_x += dx;
  cursor_y += dy;
  cursor.setAttribute('cx', cursor_x);
  cursor.setAttribute('cy', cursor_y);
};

const DEG1 = Math.PI / 180;

/**
  直線状の壁を生成する。
   (x1, x2) : 始点
   (x2, y2) : 終点
   // 以下オプショナル引数
   (cx, cy) : 回転する時の中心
   a: 回転速度（deg/tick)
**/
function createLine(x1,y1, x2,y2, cx=0,cy=0, a=0, init=0) {
  return {
    type:"L", x1: x1, y1: y1, x2: x2, y2: y2, rot: { cx: cx, cy: cy,
              x1: x1, y1: y1, x2: x2, y2: y2, a: a, i: init }
  };
}

/**
  円弧状の壁を生成する。
   (x0, y0) : 円弧の中心座標（みえない）
   r : 円弧の半径
   ap : 円弧の始点の、中心座標から見た時の極座標
   aq : 円弧の終点の、中心座標から見た時の極座標
   // 以下オプショナル引数
   (cx, cy) : 回転の中心
   a : 回転速度(deg/tick)
**/
function createArc(x0, y0, r, ap, aq, cx=0, cy=0, a=0, init=0) {
  console.log("(",x0, y0, r, ap, aq,")");
  const x1 = x0 + r * Math.cos(ap*DEG1);
  const y1 = y0 + r * Math.sin(ap*DEG1);
  const x2 = x0 + r * Math.cos(aq*DEG1);
  const y2 = y0 + r * Math.sin(aq*DEG1);
  console.log(">>>",
    Math.round(x1*10000)/10000,
    Math.round(y1*10000)/10000,
    Math.round(x2*10000)/10000,
    Math.round(y2*10000)/10000);
  return {
    type: "A", x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0: y0, r: r, rot: { cx: cx, cy: cy,
               x1: x1, y1: y1, x2: x2, y2: y2, x0: x0, y0, y0, a: a, i: init }
  };
}

// 障害物
const walls = [
//  createLine( 60, 30, 60,130, 88.8675, 80, 1),
//  createLine( 60,130,147, 80, 88.8675, 80, 1),
//  createLine(147, 80, 60, 30, 88.8675, 80, 1),
//  {type: "z"},
  //         x0, y0,   r,  ap,     aq,       cx, cy,  a
  createArc(247, 80, 100, 150, 150+60, 188.8675, 80, -1),
  createArc(160,130, 100, 270, 270+60, 188.8675, 80, -1),
  createArc(160, 30, 100,  30,  30+60, 188.8675, 80, -1),
  {type: "z"},
];

// SVG生成
function resetSVG() {
  // カーソル以外を削除する
  // ※冒頭がカーソルであることを前提にしている
  /* https://freefielder.jp/blog/2015/09/javascript-remove-childnodes.html */
  while(svg.childElementCount>=2) {
    svg.removeChild(svg.lastChild);
  }
  let d = "M";
  let last = {x:0, y:0};
  for(let i=0;i<walls.length;i++) {
    const w = walls[i];
    if(w.type=="L") {
      if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
      d = d + "L" + w.x2 + " " + w.y2 + " ";
    }
    if(w.type=="A") {
      if(d=="M") d = d + w.x1 + " " + w.y1 + " ";
      d = d + "A" + w.r + " " + w.r + " 0 0 1 " + w.x2 + " " + w.y2 + " ";
    }
    // pathを閉じる
    if(w.type=="z") {
      d = d + "z";
      const path = document.createElementNS(NS, 'path');
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('fill', 'none');
      svg.appendChild(path);
      d = "M";
    }
  }
  //test
  const c = document.createElementNS(NS, 'circle');
  c.setAttribute('cx', 247);
  c.setAttribute('cy', 80);
  c.setAttribute('r', 99);
  c.setAttribute('stroke', "#FF9900");
  c.setAttribute('fill', "none");
  svg.appendChild(c);
}

resetSVG();

// 入力判定
document.body.addEventListener('keydown',event=>{
  if(event.key==='d') { move(+10, 0); }
  if(event.key==='a') { move(-10, 0); }
  if(event.key==='w') { move(0, -10); }
  if(event.key==='s') { move(0, +10); }
});

// 当たり判定
function collision() {
  debugwrite.textContent = "";
  return walls.map(w=>{

    if(w.type=="L") {
      // https://yttm-work.jp/collision/collision_0006.html
      // 高校数学かなり忘れてて悲しくなった。
      const wx = w.x2 - w.x1;
      const wy = w.y2 - w.y1;
      const ux = cursor_x - w.x1;
      const uy = cursor_y - w.y1;
      const vx = cursor_x - w.x2;
      const vy = cursor_y - w.y2;
      const det = wx * uy - wy * ux;
      const len = Math.sqrt( wx*wx + wy*wy );
      const dst =  Math.abs(det) / len;
      if(dst > cursor_r) {
        return false; // 直線と中心の法線距離が十分遠ければ、触れていない
      }
      const dot1 = wx * ux + wy * uy;
      const dot2 = wx * vx + wy * vy;
      if(dot1*dot2 < 0) {
        // 壁ベクトルと、両端から中心までのベクトルとの、２つの内積の符号が異なる
        // ＝線分と円は触れている
        return true;
      }
      const v = Math.sqrt( vx*vx + vy*vy );
      // あとは、線分の終点が円内にあるかないかで決定する
      return (v <= cursor_r);
    }
    if(w.type=="A") {
      const dx = cursor_x - w.x0;
      const dy = cursor_y - w.y0;
      // 円弧の中心からの距離
      const d = Math.sqrt( dx*dx + dy*dy );
      if( Math.abs(w.r - cursor_r) < d && d < w.r + cursor_r ){
        // 全円には接している。

        const a1 = Math.atan2((w.y1    -w.y0),(w.x1    -w.x0));
        let ac = Math.atan2((cursor_y-w.y0),(cursor_x-w.x0));
        let a2 = Math.atan2((w.y2    -w.y0),(w.x2    -w.x0));
        while(ac<a1) { ac += 2 * Math.PI; }
        while(a2<a1) { a2 += 2 * Math.PI; }
        //debugwrite.innerHTML = "<div>"+d+"</div>"+
        //                       "<div>"+(a1/DEG1)+"</div>"+
        //                       "<div>"+(ac/DEG1)+"</div>"+
        //                       "<div>"+(a2/DEG1)+"</div>";
        return ( a1 < ac && ac < a2 );
        ////return ( a2 < ac && ac < a1 );
        return true;
      }
      return false;

    }

    // なんでもない＝衝突してない
    return false;

  }).reduce((a,b)=>a||b);
}
	</script>
        <script> const timerField = document.getElementById('timer'); const StartTimer = (function(){ let timerID = -1;
  return function(ms) {
    if(timerID!=-1) {
      clearInterval(timerID);
      timerID = -1;
    }
    if(timerField.textContent.indexOf('0')>=0){
      return false; // 二重起動防止（仮）
    }
    const limit = ms;
    const start = Date.now();
    timerID = setInterval(
      limit=="inf" ?
      function(){
        rotations();
        resetSVG();
        if(collision()){
          cursor.setAttribute('fill', 'red');
        }else{
          cursor.setAttribute('fill', 'yellow');
        }
      } :
      function(){
        //{{{#section: 時限性の時の処理
        const now = Date.now();
        let rest= Math.max(0, limit - (now - start));
        const min = Math.floor(rest/60000);
        const sec = Math.floor((rest%60000)/1000);
        const mls = Math.floor((rest%1000)/10);
        timerField.textContent = 
          ('00'+min).slice(-2) + ':' +
          ('00'+sec).slice(-2) + '.' +
          ('00'+mls).slice(-2);
        if(rest == 0) {
          alert('Time Up!');
          clearInterval(timerID);
          timerField.textContent = "--:--.--";
          return;
        }
        //}}}#section
        // 共通処理
    }, 10);
    return true;
  };
})();

// 回転アニメーションのコマ処理
function rotations() {
  walls.filter(w=>w.rot!=undefined).forEach(function(w){
    w.rot.i++;
    const th = w.rot.a * w.rot.i * Math.PI / 180;
    if(w.type=="L") {
      w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
    }
    if(w.type=="A") {
      w.x1 = (w.rot.x1-w.rot.cx) * Math.cos(th) - (w.rot.y1-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y1 = (w.rot.x1-w.rot.cx) * Math.sin(th) + (w.rot.y1-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x2 = (w.rot.x2-w.rot.cx) * Math.cos(th) - (w.rot.y2-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y2 = (w.rot.x2-w.rot.cx) * Math.sin(th) + (w.rot.y2-w.rot.cy) * Math.cos(th) + w.rot.cy;
      w.x0 = (w.rot.x0-w.rot.cx) * Math.cos(th) - (w.rot.y0-w.rot.cy) * Math.sin(th) + w.rot.cx;
      w.y0 = (w.rot.x0-w.rot.cx) * Math.sin(th) + (w.rot.y0-w.rot.cy) * Math.cos(th) + w.rot.cy;
    }
  });
}
        </script>
</html>
